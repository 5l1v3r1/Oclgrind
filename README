========
Oclgrind
========

About
-----
This project implements a virtual OpenCL device simulator, including
an OpenCL runtime with ICD support. The goal is to provide a debugging
aid for OpenCL development. The simulator is built on an interpreter
for SPIR. This is a side-project is being undertaken by James Price (a
PhD student at the University of Bristol).

This project is currently in beta, and so you may encounter issues
when running it. If you do, please get in touch using the contact
details below.


Building
--------
To use this project you will require a version of Clang that is
capable of generating SPIR. The Khronos working group has made a
patched version of Clang 3.2 that can generate SPIR available on
GitHub:

https://github.com/KhronosGroup/SPIR

Follow the instructions in the README.md file in that repository to
build the Clang/SPIR generator. To improve the performance of
Oclgrind, it is recommended to build for release mode (i.e. set
CMAKE_BUILD_TYPE to RelWithDebInfo).

Run ./configure to generate the Makefile, optionally using
--prefix=PATH to specify the target installation directory. If you
don't have the Clang/SPIR generator includes and libraries on your
search path, you can specify the location of the generator using the
--with-spir=PATH option. For example:

./configure --prefix=$PWD/build/ --with-spir=PATH/TO/CLANG/SPIR/BUILD

Next, build with make:

make (or make install)

Ensure that the lib directory in the Clang/SPIR generator build is
covered by your dynamic library search path, adding it to
[DY]LD_LIBRARY_PATH if necessary.

An ICD entry point containing the path to liboclgrind.{so,dylib}
should be created in /etc/OpenCL/vendors/. If you don't already have
the OpenCL ICD installed, download and build the sources from the
Khronos website:

http://www.khronos.org/registry/cl/

To build the OpenCL ICD on OS X, modify the CMakeLists.txt file such
that the first comparison of ${CMAKE_SYSTEM_NAME} with the string
"Linux" instead compares to the string "Darwin"


Usage
-----
If installed correctly, Oclgrind should appear as a platform when an
application calls clGetPlatformIDs(). To run an OpenCL application
with Oclgrind, simply target this platform and its only device (a CPU
device). If it encounters any invalid memory accesses, Oclgrind will
report the details to stderr, for example:

> Invalid read of size 4 at global memory address 1000000000040
>         Work-item:  Global(16,0,0) Local(0,0,0)
>         Work-group: (16,0,0)
>         Kernel:     vecadd
>         %tmp8 = load float addrspace(1)* %tmp7, align 4, !dbg !47
>         At line 16 of input.cl

Since it is interpreting an abstract intermediate representation and
bounds-checking each memory access, Oclgrind will run very slowly
(typically several orders of magnitude slower than a regular CPU
implementation). Therefore, it is recommended to run with a small
problem if possible.

To enable an interactive, GDB-style debugging session, export the
environment variable OCLGRIND_INTERACTIVE=1. This will automatically
break at the beginning of each kernel invocation, and upon
encountering an invalid memory access. Type 'help' for details of
available commands. This feature is currently very limited, and will
likely be improved in the future.


Contact
-------
If you encounter any issues or have any questions, please use the
GitHub issues page:
https://github.com/jrprice/Oclgrind/issues

You can also contact the developer via email:
James Price <j.price@bristol.ac.uk>
